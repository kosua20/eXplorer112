
#include "../engine/engine.glsl"

layout(local_size_x=SORT_ITEMS_PER_BATCH, local_size_y=1, local_size_z=1) in;

layout(set = 0, binding = 1) uniform TransparentFrameData {
	uint firstMesh;
	uint meshCount;
	uint instanceCount;
	uint firstBit;
	uint batchCount;
} transparentEngine;

layout(set = 0, binding = 2) readonly buffer TransparentCounter {
	uint transparentInstanceCounter[];
};

layout(set = 0, binding = 3) readonly buffer TransparentInfos {
	TransparentInstanceInfos transparentInfos[];
};

layout(set = 0, binding = 4) coherent buffer BinCounters {
	uint counters[];
};

void main(){
	
	if(gl_GlobalInvocationID.x >= transparentInstanceCounter[0]){
		return;
	}

	TransparentInstanceInfos infos = transparentInfos[gl_GlobalInvocationID.x];
	uint maskedDistance = (infos.distanceToCamera >> transparentEngine.firstBit) & (SORT_BIN_COUNT - 1u);
	// Reverse order, draw from furthest to closest.
	uint binIndex = SORT_BIN_COUNT - 1u - maskedDistance;
	// Increment dedicated counter. This could be done in shared memory before a unique thread write it to buffer memory.
	uint counterIndex = SORT_BIN_COUNT * gl_WorkGroupID.x + binIndex;
	atomicAdd(counters[counterIndex], 1);
}
