
#extension GL_EXT_nonuniform_qualifier : enable
#include "samplers.glsl"
#include "engine.glsl"

layout(local_size_x=8, local_size_y=8, local_size_z=1) in;

layout(set = 2, binding = 0) uniform texture2D  sceneDepth;
layout(set = 2, binding = 1) uniform texture2D fogXYMap;
layout(set = 2, binding = 2) uniform texture2D fogZMap;

layout(set = 2, binding = 3, rgba16f) uniform readonly image2D sceneLit;
layout(set = 2, binding = 4, rgba16f) uniform writeonly image2D sceneFog;

#include "fog.glsl"

vec3 viewPositionFromDepth(float depth, vec2 pix){
	// Linearize depth -> in view space.
	float viewDepth =  -engine.p[3][2] / (depth + engine.p[2][2]);
	// Compute the x and y components in view space.
	vec2 ndcPos = 2.0 * (pix / engine.resolution.xy) - 1.0;
	vec3 viewPos = vec3(-ndcPos * viewDepth / vec2(engine.p[0][0], engine.p[1][1]) , viewDepth);
	return vec3(engine.iv * vec4(viewPos, 1.0));
}

void main(){
	// Safety exit.
	if(any(greaterThanEqual(gl_GlobalInvocationID.xy, engine.resolution.xy ))){
		return;
	}
	ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

	float depth = texelFetch(sampler2D(sceneDepth, sClampNear), pixelCoord, 0).r;

	vec4 finalColor = imageLoad(sceneLit, pixelCoord);

	// Skip on background.
	if(depth < 1.0){
		vec3 worldPos = viewPositionFromDepth(depth, pixelCoord);
		vec3 viewDir = engine.camPos.xyz - worldPos;

		float fogFactor = applyFog(worldPos.y, viewDir);
		finalColor.rgb = mix(finalColor.rgb, engine.fogColor.rgb, fogFactor);
	}
	imageStore(sceneFog, pixelCoord, finalColor);
}

